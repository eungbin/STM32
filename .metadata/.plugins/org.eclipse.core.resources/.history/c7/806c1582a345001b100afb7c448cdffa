#include "stm32f0xx_hal.h"
#include "main.h"
#include "AM2302.h"

uint8_t AM2302ReadData(AM2302DATA *pData)
{
    uint32_t tmp;
    uint32_t i;
    uint16_t data[AM2302_DATA_BITS] = {0,};

    pData->humid = pData->temp = pData->checksum = 0;
    // set AM2302_DATA Pin for output
    tmp = AM2302_DATA_GPIO_Port->AFR;
    tmp &= 0x0FFFFFFF;
    tmp |= 0x20000000;
    AM2302_DATA_GPIO_Port->BRR = tmp;

    // transmit start signal
    AM2302_DATA_GPIO_Port->BSRR = AM2302_DATA_Pin;
    HAL_Delay(250);
    AM2302_DATA_GPIO_Port->BRR = AM2302_DATA_Pin;
    HAL_Delay(1);
    AM2302_DATA_GPIO_Port->BSRR = AM2302_DATA_Pin;

    // set AM2302_DATA Pin for  pull-up input
    tmp = AM2302_DATA_GPIO_Port->BRR;
    AM2302_DATA_GPIO_Port->ODR = AM2302_DATA_Pin;
    tmp &= 0x0FFFFFFF;
    tmp |= 0x80000000;
    AM2302_DATA_GPIO_Port->BRR = tmp;

    // wait for AM2302's reply
    if(WaitForLow(AM2302_MAX_REPLY_TIME) > AM2302_MAX_REPLY_TIME)
        return AM2302_NOT_REPLY;

    // AM2302's low signal
    if(WaitForHigh(AM2302_SIGNAL_LENGTH) > AM2302_SIGNAL_LENGTH)
        return AM2302_SIGNAL_ERR;

    // wait for data
    if(WaitForLow(AM2302_SIGNAL_LENGTH) > AM2302_SIGNAL_LENGTH)
        return AM2302_DATA_NOT_START;

    // put 40 wait repeat times to array data[]
    for(i = 0;i < AM2302_DATA_BITS;i++)
    {
        WaitForHigh(AM2302_DATA_LOW_LENGTH);
        data[i] = WaitForLow(AM2302_DATA_HIGH_LENGTH_1);
        if(data[i] > AM2302_DATA_HIGH_LENGTH_1)                 // error occurred
            return (AM2302_DATA_HIGH_ERR + i);
    }

    // calculate humidity
    for(i = 0;i < 16;i++)
    {
        if(i > 0) pData->humid <<= 1;
        if(data[i] > AM2302_DATA_HIGH_LENGTH_0)
            pData->humid |= 1;
    }

    // calculate temp
    for(;i < 32;i++)
    {
        if(i > 16) pData->temp <<= 1;
        if(data[i] > AM2302_DATA_HIGH_LENGTH_0)
            pData->temp |= 1;
    }

    // calculate checksum
    for(;i < AM2302_DATA_BITS;i++)
    {
        if(i > 32) pData->checksum <<= 1;
        if(data[i] > AM2302_DATA_HIGH_LENGTH_0)
            pData->checksum |= 1;
    }

    // check checksum
    if(pData->checksum != (pData->humid / 256 + pData->humid % 256 + pData->temp / 256 + pData->temp % 256) % 256)
        return AM2302_CHKSUM_ERR;
    return AM2302_SUCCESS;
}

uint32_t WaitForLow(uint32_t max)
{
    uint32_t time = 0;
    while((AM2302_DATA_GPIO_Port->IDR & AM2302_DATA_Pin) && (time++ < max));
    return time;
}

uint32_t WaitForHigh(uint32_t max)
{
    uint32_t time = 0;
    while(!(AM2302_DATA_GPIO_Port->IDR & AM2302_DATA_Pin) && (time++ < max));
    return time;
}
